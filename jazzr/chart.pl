%merge(P, Q, Res):-
%  true.

%merge(P, Q, R, Res):-
%  true.


maxdepth(8).

validspan(L, Begin, End):-
  L =:= End - Begin.

combine([S], [S]):- !.
combine([], []):- !.

combine([on(L1, Begin), length(L2) | Rest], Combined):-
  !,
  L is L1 + L2,
  combine([on(L, Begin)| Rest], Combined).

combine([on(L1, Begin1), on(L2, Begin2) | Rest], [span(L1, Begin1, Begin2) | Combined]):-
  !,
  validspan(L1, Begin1, Begin2),
  combine([on(L2, Begin2) | Rest], Combined).

combine([on(L1, Begin1),  span(L2, Begin2, End) | Rest], [span(L1, Begin1, Begin2), span(L2, Begin2, End) | Combined]):-
  !,
  validspan(L1, Begin1, Begin2),
  combine(Rest, Combined).

combine([length(L1), on(L2, Begin) | Rest], [length(L1) | Combined]):-
  combine([on(L2, Begin) | Rest], Combined).

combine([span(L1, Begin1, End), on(L2, Begin2) | Rest], [span(L1, Begin1, End) | Combined]):-
  combine([on(L2, Begin2) | Rest], Combined).

combine([span(L1, Begin1, End1), span(L2, Begin2, End2) | Rest], [span(L1, Begin1, End1), span(L2, Begin2, End2) | Combined]):-
  combine(Rest, Combined).

rule(beat(Bd), [beat(D), beat(D)]):-
  D is Bd/2.

rule(beat(Bd), [beat(D), beat(D), beat(D)]):-
  D is Bd/3.

lex(beat(D), On, [on(D, On)]).

lex(beat(D), [], [length(D)]).

parse(Notes, Tree, Spans):-
  parse(Notes, [beat(1)], Tree, [], Spans, 0).

parse(Notes, [], [], Notes, [], _).

% See if the first item is generated by a rule
parse([Note | Notes], [Rule | Rest], [Rule | RestRules], NewNotes, F, D):-
  maxdepth(Md),
  D =< Md,
  lex(Rule, Note, F1),
  NewD is D + 1,
  parse(Notes, Rest, RestRules, NewNotes, F2, NewD),
  append(F1, F2, S), 
  combine(S, F).
  %append(F1, F2, F).

% Expand a rule and try to parse again
parse(Notes, [Rule | Rest], [Rule, SubRules | RestRules], NewNotes, F, D):-
  maxdepth(Md),
  D =< Md,
  rule(Rule, Expanded),
  NewD is D + 1,
  parse(Notes, Expanded, SubRules, LeftOver, F1, NewD), 
  parse(LeftOver, Rest, RestRules, NewNotes, F2, NewD),
  append(F1, F2, S),
  combine(S, F).
  %append(F1, F2, F).


